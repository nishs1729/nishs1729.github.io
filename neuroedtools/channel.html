<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stochastic Channel Simulation</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }
        h3 {
            margin-top: 0;
        }
        p.description {
            max-width: 800px;
            text-align: left;
            margin-bottom: 10px;
            line-height: 1.5;
        }
        .model-section {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
        }
        .model-section:last-child {
            border-bottom: none;
        }
        .main-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 20px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 350px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            font-size: 0.9em;
            flex-basis: 150px;
        }
        input[type="range"] {
            flex-grow: 1;
        }
        .plots-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .plot-group {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 10px;
        }
    </style>
</head>
<body>
    <h1>Stochastic Channel Simulation</h1>

    <!-- Part 1: Simple Gating (Constant Rates) -->
    <div class="model-section">
        <h2>Part 1: Simple Gating with Constant Rates</h2>
        <div class="main-container">
            <div class="controls">
                <div class="slider-container">
                    <label for="alpha_p1">Alpha (Opening Rate)</label>
                    <input type="range" id="alpha_p1" min="0.01" max="0.99" value="0.1" step="0.01">
                    <span id="alpha_p1-value">0.01</span>
                </div>
                <div class="slider-container">
                    <label for="beta_p1">Beta (Closing Rate)</label>
                    <input type="range" id="beta_p1" min="0.01" max="0.99" value="0.2" step="0.01">
                    <span id="beta_p1-value">0.02</span>
                </div>
                <div class="slider-container">
                    <label for="num_channels_p1">Number of Channels</label>
                    <input type="range" id="num_channels_p1" min="1" max="100" value="1" step="1">
                    <span id="num_channels_p1-value">10</span>
                </div>
                <div class="slider-container">
                    <label for="duration_p1">Simulation Duration (ms)</label>
                    <input type="range" id="duration_p1" min="10" max="200" value="100" step="1">
                    <span id="duration_p1-value">200</span>
                </div>
                <img src="assets/images/channel1.png" alt="Channel state diagram for Part 1" style="width: 100%; height: auto; margin-top: 15px;">
            </div>
            <div class="plots-container">
                <div class="plot-group">
                    <canvas id="individual-plot-p1" width="800" height="300"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="total-plot-p1" width="800" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Part 2: Single Voltage-Dependent Gate -->
    <div class="model-section">
        <h2>Part 2: Single Voltage-Dependent Gate</h2>
        <div class="main-container">
            <div class="controls">
                <div class="slider-container">
                    <label for="voltage_p2">Membrane Voltage (mV)</label>
                    <input type="range" id="voltage_p2" min="-100" max="100" value="-20" step="1">
                    <span id="voltage_p2-value">-20</span>
                </div>
                <div class="slider-container">
                    <label for="num_channels_p2">Number of Channels</label>
                    <input type="range" id="num_channels_p2" min="1" max="100" value="1" step="1">
                    <span id="num_channels_p2-value">1</span>
                </div>
                <div class="slider-container">
                    <label for="duration_p2">Simulation Duration (ms)</label>
                    <input type="range" id="duration_p2" min="10" max="200" value="100" step="1">
                    <span id="duration_p2-value">100</span>
                </div>
                <canvas id="ab_plot_p2" width="310" height="180"></canvas>
                <img src="assets/images/channel2.png" alt="Channel state diagram for Part 2" style="width: 100%; height: auto; margin-top: 15px;">
            </div>
            <div class="plots-container">
                <div class="plot-group">
                    <canvas id="individual-plot-p2" width="800" height="300"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="open-channels-plot-p2" width="800" height="200"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="total-plot-p2" width="800" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Part 3: Full Potassium Channel (4 Gates) -->
    <div class="model-section">
        <h2>Part 3: Full Potassium (K+) Channel</h2>
        <div class="main-container">
            <div class="controls">
                 <div class="slider-container">
                    <label for="voltage_p3">Membrane Voltage (mV)</label>
                    <input type="range" id="voltage_p3" min="-100" max="100" value="-20" step="1">
                    <span id="voltage_p3-value">-20</span>
                </div>
                <div class="slider-container">
                    <label for="num_channels_p3">Number of Channels</label>
                    <input type="range" id="num_channels_p3" min="1" max="100" value="5" step="1">
                    <span id="num_channels_p3-value">5</span>
                </div>
                <div class="slider-container">
                    <label for="duration_p3">Simulation Duration (ms)</label>
                    <input type="range" id="duration_p3" min="10" max="200" value="100" step="1">
                    <span id="duration_p3-value">200</span>
                </div>
                <canvas id="ab_plot_p3" width="310" height="180"></canvas>
                <img src="assets/images/channel3.png" alt="Channel state diagram for Part 3" style="width: 100%; height: auto; margin-top: 15px;">
            </div>
            <div class="plots-container">
                <div class="plot-group">
                    <canvas id="individual-plot-p3" width="800" height="300"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="open-channels-plot-p3" width="800" height="200"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="total-plot-p3" width="800" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Part 4: Full Sodium Channel (3m, 1h Gates) -->
    <div class="model-section">
        <h2>Part 4: Full Sodium (Na+) Channel</h2>

        <div class="main-container">
            <div class="controls">
                <div class="slider-container">
                    <label for="voltage_p4">Membrane Voltage (mV)</label>
                    <input type="range" id="voltage_p4" min="-100" max="100" value="-20" step="1">
                    <span id="voltage_p4-value">-20</span>
                </div>
                <div class="slider-container">
                    <label for="num_channels_p4">Number of Channels</label>
                    <input type="range" id="num_channels_p4" min="1" max="100" value="5" step="1">
                    <span id="num_channels_p4-value">5</span>
                </div>
                <div class="slider-container">
                    <label for="duration_p4">Simulation Duration (ms)</label>
                    <input type="range" id="duration_p4" min="10" max="200" value="100" step="1">
                    <span id="duration_p4-value">100</span>
                </div>
                <canvas id="ab_plot_p4_m" width="310" height="180"></canvas>
                <canvas id="ab_plot_p4_h" width="310" height="180"></canvas>
                <img src="assets/images/channel4.png" alt="Channel state diagram for Part 4" style="width: 100%; height: auto; margin-top: 15px;">
            </div>
            <div class="plots-container">
                <div class="plot-group">
                    <canvas id="individual-plot-p4" width="800" height="300"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="open-channels-plot-p4" width="800" height="200"></canvas>
                </div>
                <div class="plot-group">
                    <canvas id="total-plot-p4" width="800" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- General Helper Functions ---
        function drawAxis(ctx, padding, plotWidth, plotHeight, title, xLabel, yLabel) {
            const canvas = ctx.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.font = 'bold 16px sans-serif';
            ctx.fillText(title, padding.left + plotWidth / 2, padding.top - 10);
            ctx.font = '14px sans-serif';
            ctx.fillText(xLabel, padding.left + plotWidth / 2, padding.top + plotHeight + 35);

            ctx.save();
            ctx.translate(padding.left - 50, padding.top + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();

            ctx.beginPath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + plotHeight);
            ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
            ctx.stroke();
        }

        function drawXAxisTicks(ctx, duration, padding, plotWidth) {
            ctx.textAlign = 'center';
            ctx.fillStyle = '#333';
            for (let i = 0; i <= 5; i++) {
                const val = (duration / 5) * i;
                const x = padding.left + (i / 5) * plotWidth;
                ctx.fillText(val.toFixed(0), x, padding.top + ctx.canvas.height - padding.top - padding.bottom + 20);
            }
        }
        
        function drawIndividualChannelsPlot(ctx, traces, duration, N, title) {
            const canvas = ctx.canvas;
            const padding = { top: 40, right: 20, bottom: 40, left: 70 };
            const plotWidth = canvas.width - padding.left - padding.right;
            const plotHeight = canvas.height - padding.top - padding.bottom;

            drawAxis(ctx, padding, plotWidth, plotHeight, title, 'Time (ms)', 'Channel #');
            drawXAxisTicks(ctx, duration, padding, plotWidth);

            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            traces.forEach((trace, i) => {
                const y = padding.top + (plotHeight * (i + 0.5)) / N;
                trace.forEach(point => {
                    if (point.state === 1) {
                        const x = padding.left + (point.t / duration) * plotWidth;
                        ctx.beginPath();
                        ctx.moveTo(x, y - 2);
                        ctx.lineTo(x, y + 2);
                        ctx.stroke();
                    }
                });
            });

            ctx.textAlign = 'right';
            ctx.fillStyle = '#333';
            for (let i = 0; i < N; i++) {
                if (N <= 20 || (i + 1) % 10 === 0 || N < 10) {
                    const y = padding.top + (plotHeight * (i + 0.5)) / N;
                    ctx.fillText(i + 1, padding.left - 8, y + 4);
                }
            }
        }

        function drawTotalTracePlot(ctx, trace, duration, title, yLabel) {
            const canvas = ctx.canvas;
            const padding = { top: 40, right: 20, bottom: 40, left: 70 };
            const plotWidth = canvas.width - padding.left - padding.right;
            const plotHeight = canvas.height - padding.top - padding.bottom;
            
            const allValues = trace.map(p => p.value);
            let minVal = Math.min(...allValues);
            let maxVal = Math.max(...allValues);
            if (minVal === maxVal) {
                minVal -= 1;
                maxVal += 1;
            }

            drawAxis(ctx, padding, plotWidth, plotHeight, title, 'Time (ms)', yLabel);
            drawXAxisTicks(ctx, duration, padding, plotWidth);

            ctx.beginPath();
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 1.5;
            trace.forEach((point, i) => {
                const x = padding.left + (point.t / duration) * plotWidth;
                const y_val = (point.value - minVal) / (maxVal - minVal || 1);
                const y = padding.top + plotHeight - y_val * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            ctx.textAlign = 'right';
            ctx.fillStyle = '#333';
            for (let i = 0; i <= 4; i++) {
                const val = minVal + (maxVal - minVal) * (i / 4);
                const y = padding.top + plotHeight - (i / 4) * plotHeight;
                ctx.fillText(val.toFixed(yLabel.includes('(pA)') ? 1 : 0), padding.left - 8, y + 4);
            }
        }
        
        function drawAlphaBetaPlot(ctx, alphaFn, betaFn, color1, color2, label1, label2, rateMax, currentV = null) {
            const canvas = ctx.canvas;
            const padding = { top: 20, right: 15, bottom: 40, left: 45 };
            const plotWidth = canvas.width - padding.left - padding.right;
            const plotHeight = canvas.height - padding.top - padding.bottom;

            const vMin = -100, vMax = 100;
            const rateMin = 0;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText('Voltage (mV)', padding.left + plotWidth / 2, padding.top + plotHeight + 30);
            
            ctx.save();
            ctx.translate(padding.left - 35, padding.top + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Rate', 0, 0);
            ctx.restore();

            ctx.beginPath();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.moveTo(padding.left, padding.top + plotHeight);
            ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + plotHeight);
            ctx.stroke();

            const alphaPoints = [];
            const betaPoints = [];
            for (let v = vMin; v <= vMax; v += 2) {
                alphaPoints.push({v, rate: alphaFn(v)});
                betaPoints.push({v, rate: betaFn(v)});
            }

            function plotCurve(points, color) {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                points.forEach((p, i) => {
                    const x = padding.left + ((p.v - vMin) / (vMax - vMin)) * plotWidth;
                    const y = padding.top + plotHeight - ((p.rate - rateMin) / (rateMax - rateMin)) * plotHeight;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            plotCurve(alphaPoints, color1);
            plotCurve(betaPoints, color2);

            ctx.font = 'bold 12px sans-serif';
            ctx.fillStyle = color1;
            ctx.fillText(label1, padding.left + plotWidth - 10, padding.top + 10);
            ctx.fillStyle = color2;
            ctx.fillText(label2, padding.left + plotWidth - 10, padding.top + 25);
            
            ctx.textAlign = 'right';
            ctx.fillStyle = '#333';
            ctx.font = '10px sans-serif';
            for (let i = 0; i <= 2; i++) {
                const val = rateMin + (rateMax - rateMin) * (i / 2);
                const y = padding.top + plotHeight - (i / 2) * plotHeight;
                ctx.fillText(val.toFixed(2), padding.left - 5, y + 3);
            }

            ctx.textAlign = 'center';
            for (let i = 0; i <= 4; i++) {
                const val = vMin + (vMax - vMin) * (i / 4);
                const x = padding.left + (plotWidth * i / 4);
                ctx.fillText(val.toFixed(0), x, padding.top + plotHeight + 15);
            }

            if (currentV !== null) {
                const x = padding.left + ((currentV - vMin) / (vMax - vMin)) * plotWidth;
                ctx.beginPath();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + plotHeight);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // --- Hodgkin-Huxley Rate Functions ---
        const HH = {
            alpha_n: V => (V === -55.0) ? 0.1 : (0.01 * (V + 55)) / (1 - Math.exp(-0.1 * (V + 55))),
            beta_n: V => 0.125 * Math.exp(-0.0125 * (V + 65)),
            alpha_m: V => (V === -40.0) ? 1.0 : (0.1 * (V + 40)) / (1 - Math.exp(-0.1 * (V + 40))),
            beta_m: V => 4 * Math.exp(-0.0556 * (V + 65)),
            alpha_h: V => 0.07 * Math.exp(-0.05 * (V + 65)),
            beta_h: V => 1 / (1 + Math.exp(-0.1 * (V + 35)))
        };

        // --- Part 1 Simulation ---
        const sim1 = {
            sliders: {
                alpha: document.getElementById('alpha_p1'),
                beta: document.getElementById('beta_p1'),
                numChannels: document.getElementById('num_channels_p1'),
                duration: document.getElementById('duration_p1'),
            },
            values: {
                alpha: document.getElementById('alpha_p1-value'),
                beta: document.getElementById('beta_p1-value'),
                numChannels: document.getElementById('num_channels_p1-value'),
                duration: document.getElementById('duration_p1-value'),
            },
            individualCtx: document.getElementById('individual-plot-p1').getContext('2d'),
            totalCtx: document.getElementById('total-plot-p1').getContext('2d'),

            init() { this.setup(); },
            setup() {
                for (const key in this.sliders) {
                    this.sliders[key].addEventListener('input', () => {
                        this.updateSliderValues();
                        this.runSimulation();
                    });
                }
                this.updateSliderValues();
                this.runSimulation();
            },
            updateSliderValues() {
                for (const key in this.sliders) {
                    this.values[key].textContent = this.sliders[key].value;
                }
            },
            runSimulation() {
                const N = parseInt(this.sliders.numChannels.value);
                const duration = parseFloat(this.sliders.duration.value);
                const alpha = parseFloat(this.sliders.alpha.value);
                const beta = parseFloat(this.sliders.beta.value);
                const dt = 0.1;
                const p_open = alpha * dt;
                const p_close = beta * dt;

                let channels = new Array(N).fill(0);
                const individualTraces = Array.from({ length: N }, () => []);
                const totalTrace = [];

                for (let t = 0; t <= duration; t += dt) {
                    let openCount = 0;
                    for (let i = 0; i < N; i++) {
                        const rand = Math.random();
                        if (channels[i] === 0) {
                            if (rand < p_open) channels[i] = 1;
                        } else {
                            if (rand < p_close) channels[i] = 0;
                        }
                        individualTraces[i].push({ t, state: channels[i] });
                        if (channels[i] === 1) openCount++;
                    }
                    totalTrace.push({ t, value: openCount });
                }
                drawIndividualChannelsPlot(this.individualCtx, individualTraces, duration, N, 'Individual Channel Activity');
                drawTotalTracePlot(this.totalCtx, totalTrace, duration, 'Total Open Channels', '# Open');
            }
        };

        // --- Part 2 Simulation ---
        const sim2 = {
            sliders: {
                voltage: document.getElementById('voltage_p2'),
                numChannels: document.getElementById('num_channels_p2'),
                duration: document.getElementById('duration_p2'),
            },
            values: {
                voltage: document.getElementById('voltage_p2-value'),
                numChannels: document.getElementById('num_channels_p2-value'),
                duration: document.getElementById('duration_p2-value'),
            },
            individualCtx: document.getElementById('individual-plot-p2').getContext('2d'),
            openChannelsCtx: document.getElementById('open-channels-plot-p2').getContext('2d'),
            totalCtx: document.getElementById('total-plot-p2').getContext('2d'),
            abPlotCtx: document.getElementById('ab_plot_p2').getContext('2d'),
            E_K: -77.0, g_K_single: 2,

            init() { sim1.setup.bind(this)(); },
            updateSliderValues() {
                for (const key in this.sliders) { this.values[key].textContent = this.sliders[key].value; }
                const V = parseFloat(this.sliders.voltage.value);
                drawAlphaBetaPlot(this.abPlotCtx, HH.alpha_n, HH.beta_n, '#dc3545', '#007bff', 'αn', 'βn', 1, V);
            },
            runSimulation() {
                const N = parseInt(this.sliders.numChannels.value);
                const V = parseFloat(this.sliders.voltage.value);
                const duration = parseFloat(this.sliders.duration.value);
                const dt = 0.1;
                const p_open = HH.alpha_n(V) * dt;
                const p_close = HH.beta_n(V) * dt;

                let channels = new Array(N).fill(0);
                const individualTraces = Array.from({ length: N }, () => []);
                const openChannelsTrace = [];
                const totalCurrentTrace = [];

                for (let t = 0; t <= duration; t += dt) {
                    let openCount = 0;
                    for (let i = 0; i < N; i++) {
                        const rand = Math.random();
                        if (channels[i] === 0) {
                            if (rand < p_open) channels[i] = 1;
                        } else {
                            if (rand < p_close) channels[i] = 0;
                        }
                        individualTraces[i].push({ t, state: channels[i] });
                        if (channels[i] === 1) openCount++;
                    }
                    const totalCurrent = openCount * this.g_K_single * (V - this.E_K);
                    openChannelsTrace.push({ t, value: openCount });
                    totalCurrentTrace.push({ t, value: totalCurrent });
                }
                drawIndividualChannelsPlot(this.individualCtx, individualTraces, duration, N, 'Individual Gate Activity');
                drawTotalTracePlot(this.openChannelsCtx, openChannelsTrace, duration, 'Open Channels', '# Open');
                drawTotalTracePlot(this.totalCtx, totalCurrentTrace, duration, 'Total K+ Current', 'Current (pA)');
            }
        };

        // --- Part 3 Simulation ---
        const sim3 = {
            sliders: {
                voltage: document.getElementById('voltage_p3'),
                numChannels: document.getElementById('num_channels_p3'),
                duration: document.getElementById('duration_p3'),
            },
            values: {
                voltage: document.getElementById('voltage_p3-value'),
                numChannels: document.getElementById('num_channels_p3-value'),
                duration: document.getElementById('duration_p3-value'),
            },
            individualCtx: document.getElementById('individual-plot-p3').getContext('2d'),
            openChannelsCtx: document.getElementById('open-channels-plot-p3').getContext('2d'),
            totalCtx: document.getElementById('total-plot-p3').getContext('2d'),
            abPlotCtx: document.getElementById('ab_plot_p3').getContext('2d'),
            E_K: -77.0, g_K_single: 2,

            init() { sim1.setup.bind(this)(); },
            updateSliderValues() {
                for (const key in this.sliders) { this.values[key].textContent = this.sliders[key].value; }
                const V = parseFloat(this.sliders.voltage.value);
                drawAlphaBetaPlot(this.abPlotCtx, HH.alpha_n, HH.beta_n, '#dc3545', '#007bff', 'αn', 'βn', 1, V);
            },
            runSimulation() {
                const N = parseInt(this.sliders.numChannels.value);
                const V = parseFloat(this.sliders.voltage.value);
                const duration = parseFloat(this.sliders.duration.value);
                const dt = 0.1;
                const p_open = HH.alpha_n(V) * dt;
                const p_close = HH.beta_n(V) * dt;

                let channels = Array.from({ length: N }, () => [0, 0, 0, 0]);
                const individualTraces = Array.from({ length: N }, () => []);
                const openChannelsTrace = [];
                const totalCurrentTrace = [];

                for (let t = 0; t <= duration; t += dt) {
                    let openCount = 0;
                    for (let i = 0; i < N; i++) {
                        for (let j = 0; j < 4; j++) {
                            const rand = Math.random();
                            if (channels[i][j] === 0) {
                                if (rand < p_open) channels[i][j] = 1;
                            } else {
                                if (rand < p_close) channels[i][j] = 0;
                            }
                        }
                        const isOpen = channels[i].every(gate => gate === 1);
                        individualTraces[i].push({ t, state: isOpen ? 1 : 0 });
                        if (isOpen) openCount++;
                    }
                    const totalCurrent = openCount * this.g_K_single * (V - this.E_K);
                    openChannelsTrace.push({ t, value: openCount });
                    totalCurrentTrace.push({ t, value: totalCurrent });
                }
                drawIndividualChannelsPlot(this.individualCtx, individualTraces, duration, N, 'Individual Channel Activity');
                drawTotalTracePlot(this.openChannelsCtx, openChannelsTrace, duration, 'Open Channels', '# Open');
                drawTotalTracePlot(this.totalCtx, totalCurrentTrace, duration, 'Total K+ Current', 'Current (pA)');
            }
        };

        // --- Part 4 Simulation ---
        const sim4 = {
            sliders: {
                voltage: document.getElementById('voltage_p4'),
                numChannels: document.getElementById('num_channels_p4'),
                duration: document.getElementById('duration_p4'),
            },
            values: {
                voltage: document.getElementById('voltage_p4-value'),
                numChannels: document.getElementById('num_channels_p4-value'),
                duration: document.getElementById('duration_p4-value'),
            },
            individualCtx: document.getElementById('individual-plot-p4').getContext('2d'),
            openChannelsCtx: document.getElementById('open-channels-plot-p4').getContext('2d'),
            totalCtx: document.getElementById('total-plot-p4').getContext('2d'),
            abPlotCtx_m: document.getElementById('ab_plot_p4_m').getContext('2d'),
            abPlotCtx_h: document.getElementById('ab_plot_p4_h').getContext('2d'),
            E_Na: 50.0, g_Na_single: 1.5,

            init() { sim1.setup.bind(this)(); },
            updateSliderValues() {
                for (const key in this.sliders) { this.values[key].textContent = this.sliders[key].value; }
                const V = parseFloat(this.sliders.voltage.value);
                drawAlphaBetaPlot(this.abPlotCtx_m, HH.alpha_m, HH.beta_m, '#28a745', '#6f42c1', 'αm', 'βm', 5, V);
                drawAlphaBetaPlot(this.abPlotCtx_h, HH.alpha_h, HH.beta_h, '#fd7e14', '#20c997', 'αh', 'βh', 1, V);
            },
            runSimulation() {
                const N = parseInt(this.sliders.numChannels.value);
                const V = parseFloat(this.sliders.voltage.value);
                const duration = parseFloat(this.sliders.duration.value);
                const dt = 0.02;

                const p_m_open = HH.alpha_m(V) * dt;
                const p_m_close = HH.beta_m(V) * dt;
                const p_h_activate = HH.alpha_h(V) * dt;
                const p_h_inactivate = HH.beta_h(V) * dt;

                let channels = Array.from({ length: N }, () => ({ m: [0, 0, 0], h: 1 }));
                const individualTraces = Array.from({ length: N }, () => []);
                const openChannelsTrace = [];
                const totalCurrentTrace = [];

                for (let t = 0; t <= duration; t += dt) {
                    let openCount = 0;
                    for (let i = 0; i < N; i++) {
                        for (let j = 0; j < 3; j++) {
                            const rand = Math.random();
                            if (channels[i].m[j] === 0) {
                                if (rand < p_m_open) channels[i].m[j] = 1;
                            } else {
                                if (rand < p_m_close) channels[i].m[j] = 0;
                            }
                        }
                        const rand_h = Math.random();
                        if (channels[i].h === 1) {
                            if (rand_h < p_h_inactivate) channels[i].h = 0;
                        } else {
                            if (rand_h < p_h_activate) channels[i].h = 1;
                        }

                        const isOpen = channels[i].m.every(g => g === 1) && channels[i].h === 1;
                        individualTraces[i].push({ t, state: isOpen ? 1 : 0 });
                        if (isOpen) openCount++;
                    }
                    const totalCurrent = openCount * this.g_Na_single * (V - this.E_Na);
                    openChannelsTrace.push({ t, value: openCount });
                    totalCurrentTrace.push({ t, value: totalCurrent });
                }
                drawIndividualChannelsPlot(this.individualCtx, individualTraces, duration, N, 'Individual Channel Activity');
                drawTotalTracePlot(this.openChannelsCtx, openChannelsTrace, duration, 'Open Channels', '# Open');
                drawTotalTracePlot(this.totalCtx, totalCurrentTrace, duration, 'Total Na+ Current', 'Current (pA)');
            }
        };

        sim1.init();
        sim2.init();
        sim3.init();
        sim4.init();
    });
    </script>
</body>
</html>
